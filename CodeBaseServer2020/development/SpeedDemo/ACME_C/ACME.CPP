#include "source\d4all.hpp"

/* database field structure */
static FIELD4INFO fieldinfo[] =
{
   { "LOCATION", r4str, 10, 0 },
   { "LENGTH",   r4num,  2, 0 },
   { "WIDTH",    r4num,  2, 0 },
   { "HEIGHT",   r4num,  2, 0 },
   { "WEIGHT",   r4num,  3, 0 },
   { "QUANTITY", r4num,  2, 0 },
   { "COLOUR",   r4str,  6, 0 },
   { 0, 0, 0, 0 }
} ;

/* index tag structure for the character tags */
static TAG4INFO chartags[] =
{
   { "LOCTAG", "LOCATION", "", 0, 0 },
   { "COLTAG", "COLOUR",   "", 0, 0 },
   { 0, 0, 0, 0, 0 }
} ;

/* index tag structure for the numeric tags */
static TAG4INFO numtags[] =
{
   { "LENTAG", "LENGTH",   "", 0, 0 },
   { "WIDTAG", "WIDTH",    "", 0, 0 },
   { "HEITAG", "HEIGHT",   "", 0, 0 },
   { "WEITAG", "WEIGHT",   "", 0, 0 },
   { "QUATAG", "QUANTITY", "", 0, 0 },
   { 0, 0, 0, 0, 0 }
} ;

/* array of locations for the random database generator */
static char *locals[] = {  "Vancouver ",
                           "NewYork   ",
                           "LosAngeles",
                           "London    ",
                           "Paris     ",
                           "Berlin    ",
                           "Moscow    ",
                           "Tokyo     ",
                           "HongKong  ",
                           "Sydney    ",
                           "Toronto   ",
                           "Montreal  ",
                           "Victoria  ",
                           "Edmonton  ",
                           "Calgary   ",
                           "Regina    ",
                           "Saskatoon ",
                           "Winnipeg  ",
                           "Whitehorse",
                           "Halifax   " } ;

/* array of colours for the random database generator */
static char *colours[] = { "Black ",
                           "White ",
                           "Red   ",
                           "Orange",
                           "Yellow",
                           "Green ",
                           "Blue  ",
                           "Violet" } ;

const int maxval = 25 ;      /* maximum random value which can be generated */
const int minval = 11 ;      /* minimum random value which can be generated */
int rc ;                     /* variable to store function return values */
unsigned int time1, time2 ;  /* start and stop time holders */
double result ;              /* difference between time1 and time2 */
char buff[] = " ";           /* used to disply results */

void main( int argc, char *argv[] )
{
   if(argc != 2)
   {
      cout << "USAGE: ACME_C <number of records for database>"<< endl;
      exit(0) ;
   }

   long num = atol( argv[1] ) ;   /* reads in number of records for database */
   Code4 cb ;                     /* initializes CodeBase object */
   cb.memSizeBuffer = 262144 ;    /* sets Code4 attributes */
   cb.safety = 0 ;
   cb.accessMode = OPEN4DENY_RW ;
   cb.errOpen = 0 ;
   cb.errOff = 1 ;

   Data4 db ;
   db.create( cb, "CB6DEMO", fieldinfo, 0 ) ; /* creates database file */
   cb.optAll() ;            /* next three lines optimizes performance of CodeBase */
   cb.optStart() ;
   db.optimize( OPT4ALL ) ;

   /* set up Field4 variables */
   Field4 location( db, "LOCATION" ) ;
   Field4   length( db, "LENGTH"   ) ;
   Field4    width( db, "WIDTH"    ) ;
   Field4   height( db, "HEIGHT"   ) ;
   Field4   weight( db, "WEIGHT"   ) ;
   Field4 quantity( db, "QUANTITY" ) ;
   Field4   colour( db, "COLOUR"   ) ;

   /* randomizes timer */
   srand( (unsigned)time( NULL ) ) ;
   db.appendStart( 0 ) ;

   /* assings a random result to location field from location array */
   location.assign( locals[ rand() % 20 ] ) ; 
   
   int a = rand() % maxval + minval + 1 ; /* generates a random length for the anvil */
   int b = INT( a * 0.8 ) ;               /* makes anvil height 80% of length */ 
   int c = INT( b * 0.8 ) ;               /* makes anvil width 80% of height */
   length.assignLong( a ) ;
   width.assignLong( c ) ;
   height.assignLong( b ) ;
   
   /* weight is generated by dividing the product of its dimensions with their sum */
   weight.assignLong( INT( (a * b * c) / (a + b + c) ) ) ;
   
   /* random quantity and colour assigned to record */
   quantity.assignLong( rand() % 20 + 1 ) ;
   colour.assign( colours[ rand() % 6 ] ) ;
   db.append() ;

   /* Building database file */
   time1 = GetTickCount() ; /* start timer */
   for( rc = 0; rc < num; rc++ )
   {
      db.appendStart( 0 ) ;
      switch( rc % 3 ) /* will either modify location, dimensions or colour for next record */
      {                /* and copy all other aspects to new record - faster record generation */
      case 0:
         location.assign( locals[ rand() % 20 ] ) ;
         break;
      case 1:
         a = rand() % maxval + minval + 1 ;
         b = INT( a * 0.8 ) ;
         c = INT( b * 0.8 ) ;
         length.assignLong( a ) ;
         width.assignLong( c ) ;
         height.assignLong( b ) ;
         weight.assignLong( INT( (a * b * c) / (a + b + c) ) ) ;
         break;
      case 2:
         colour.assign( colours[ rand() % 6 ] ) ;
         break;
      }
      quantity.assignLong( rand() % 20 + 1 ) ; /* always assigns new, random quantity */
      db.append() ;
   }
   time2 = GetTickCount() ; /* stop timer */
   result = (double)(time2 - time1) / 1000 ; /* convert time to seconds */

   /* calculates number of records per second appended */
   if( result > 0 ) 
      sprintf( buff, "\n     Records / Second = %.0f", num / result ) ;
   else
      sprintf( buff, " " ) ;
   
   /* if time greater than one minute, convert time to minutes */
   if( result < 60 ) 
      printf( "\nTime to append %d records = %.3f sec.%s\n", num, result, buff ) ;
   else
      printf( "\nTime to append %d records = %.3f min.%s\n", num, (result / 60), buff ) ;

   db.flush() ; /* write data to disk */

   /* Building Character Index file */
   Index4 charIndex;
   time1 = GetTickCount() ;

   charIndex.create( db, "CHARTAGS", chartags ) ;
   time2 = GetTickCount() ;
   result = (double)(time2 - time1) / 1000 ;
   if( result > 0 )
      sprintf( buff, "\n     Records / Second = %.0f", num / (result / 2) ) ;
   else
      sprintf( buff, " " ) ;
   if( result < 60 )
      printf( "\nTime to build 2 Character Indexes = %.3f sec.  Time per Index = %.3f sec.%s\n", result, (result / 2), buff ) ;
   else
      printf( "\nTime to build 2 Character Indexes = %.3f min.  Time per Index = %.3f sec.%s\n", (result / 60), (result / 2), buff ) ;

   db.flush() ;

   /* Building Numeric Index file */
   Index4 numIndex;
   time1 = GetTickCount() ;
   numIndex.create( db, "NUMTAGS", numtags ) ;
   time2 = GetTickCount() ;
   result = (double)(time2 - time1) / 1000 ;
   if( result > 0 )
      sprintf( buff, "\n     Records / Second = %.0f", num / (result / 5) ) ;
   else
      sprintf( buff, " " ) ;
   if( result < 60 )
      printf( "\nTime to build 5 Numeric Indexes = %.3f sec.  Time per Index = %.3f sec.%s\n", result, (result / 5), buff ) ;
   else
      printf( "\nTime to build 5 Numeric Indexes = %.3f min.  Time per Index = %.3f sec.%s\n", (result / 60), (result / 5), buff ) ;

   db.flush() ;

   /* Natural Order Skipping Through Database */
   db.select( 0 ) ;    /* selects no tag and puts record pointer to top of database */
   rc = db.top() ;
   time1 = GetTickCount() ;
   while( rc == r4success )
      rc = db.skip( 1L ) ; /* skips through database until end of file */
   time2 = GetTickCount() ;
   result = (double)(time2 - time1) / 1000 ;
   if( result > 0 )
      sprintf( buff, "\n     Records / Second = %.0f", num / result ) ;
   else
      sprintf( buff, " " ) ;
   if( result < 60 )
      printf( "\nTime to skip through Database without an Index = %.3f sec.%s\n", result, buff ) ;
   else
      printf( "\nTime to skip through Database without an Index  = %.3f min.%s\n", (result / 60), buff ) ;


   /* Skipping Through Database with Index */
   db.select( "LOCTAG" ) ;   /* selects LOCATION tag and puts record pointer to top of database */
   rc = db.top() ;
   time1 = GetTickCount() ;
   while( rc == r4success )
      rc = db.skip( 1L ) ; /* skips through database until end of file */
   time2 = GetTickCount() ;
   result = (double)(time2 - time1) / 1000 ;
   if( result > 0 )
      sprintf( buff, "\n     Records / Second = %.0f", num / result ) ;
   else
      sprintf( buff, " " ) ;
   if( result < 60 )
      printf( "\nTime to skip through Database with an Index = %.3f sec.%s\n", result, buff ) ;
   else
      printf( "\nTime to skip through Database with an Index  = %.3f min.%s\n", (result / 60), buff ) ;

   cb.initUndo() ; /* uninitializes Code4 object */
}
